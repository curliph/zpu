<html>
<body>
<h1>Index</h1>
<ul>
<li> <a href="#fpgastarted">Getting started - FPGA</a>
<li> <a href="#swstarted">Getting started - software</a>
<li> <a href="#introduction">Architecture introduction</a>
<li> <a href="#instructionset">Instruction set</a>
<li> <a href="#startup">Custom startup code (aka crt0.s)</a>
<li> <a href="#implementing">Implementing your own ZPU</a>
<li> <a href="#vectors">Jump vectors</a>
<li> <a href="#memorymap">Memory map</a>
<li> <a href="#interrupts">Interrupts</a>
<li> <a href="#performance">Speeding up the ZPU</a>
<li> <a href="#wishbone">Wishbone</a>
<li> <a href="#zpu_core_small.vhd">About zpu_core_small.vhd</a>
<li> <a href="#zpu_core.vhd">About zpu_core.vhd</a>
<li> <a href="#nextgen">Next generation ZPU</a>
</ul>

<a name="fpgastarted"/>
<h1>Getting started - FPGA </h1>
The simplest version of the ZPU uses BRAM. When getting accustomed to the ZPU, a BRAM ZPU with a UART
is a good place to start.
<p>
You'll find a working simulation script in hdl/example/simzpu_small.do and hdl/example_medium/simzpu_medium.do, which
show simulation of the small(zpu_core_small.vhd) and medium sized ZPU(zpu_core.vhd). hdl/example/simzpu_interrupt.do
shows use of interrupts.
<p>
When implementing the ZPU, copy the following files and modify them to your needs:
<ol>
    <li>hdl/example/zpu_config.vhd - set up RAM size here
    <li>hdl/example/helloworld.vhd - dual port BRAM implementation. 
</ol>
Obviously you must also connect the ZPU to the rest of your IO subsystem. IO is memory mapped(read/write) in the ZPU.
<h2>Generating VHDL BRAM initialization </h2>

<code>
../install/bin/zpu-elf-objcopy -O binary hello.elf hello.bin<br>
java -classpath ../simulator/zpusim.jar com.zylin.zpu.simulator.tools.MakeRam hello.bin &gt;hello.bram<br>

</code>
<h2>Running example simulation</h2>
The hdl/example directory has a simulation written for Xilinx WebPack ModelSim. From the ModelSim command prompt:
<ol>
<li>cd c:/&lt;installfolder&gt;/hdl/example
<li>do zpusim_small.do
</ol>
<p>
After running the hello world simulation (see zpusim.do), two files are written to the hdl/example directory:
<ol>
<li>log.txt - contains the "Hello world!" text written to the debug channel/simplified UART.
<li>trace.txt - a trace file for the CPU. The instruction set simulator has the capability of taking
this file as input in order to verify that the HDL implementation matches the instruction set simulator. 
When a mismatch is found, the GDB debugger will break. Very handy for debugging custom ZPU implementations. 
</ol>  
<h2>HDL Directories & files </h2>
<ul>
<li>example - contains example files & working ZPU. Start here.
<li>wishbone - contains wishbone interface for the ZPU
<li>zpu3 - if you are interested in developing ZPU cores and not only using them, then this directory contains various stuff of more or less historical interest.
<li>zpu4 -  if you are interested in developing ZPU cores and not only using them, then this is the active development version. You'll also want to copy out the
files you need from this folder to your own project.
</ul>

The HDL files need a bit of spit and polish!

<a name="swstarted"/>
<h1>Getting started - software</h1>
The ZPU comes with a standard GCC toolchain and an instruction set simulator. This allows compiling, running & debugging simple test programs. The Simulator has 
some very basic peripherals defined: counter, timer interrupt and a debug output port. 
<h2>Installing</h2>
<ol>
<li>Install Cygwin. http://www.cygwin.com 
<li>Install Java
<li>Start Cygwin bash
<li>cd zpu/sw
<li>sh setup.sh
<li>/tmp/zpu/install/bin now has the .exe files for the GCC toolchain & GDB
<li>Optionally you may set up PATH variables to point to /tmp/zpu/install/bin<br>
source env.sh
</ol>
<h1>Hello world example</h1>
The ZPU toolchain comes with newlib & libstdc++ support which means that many C/C++ programs can be compiled without modification.
<p> 
<code>
cd zpu/sw/helloworld<br>
../install/bin/zpu-elf-gcc -phi hello.c -o hello.elf <br>
</code>
<h2>Running the hello world example in GDB</h2>
<ol>
<li>cd zpu/sw/helloworld
<li>Launch the simulator from a seperate bash shell:<p>
java -classpath ../simulator/zpusim.jar -Xmx512m com.zylin.zpu.simulator.Phi 4444
<p>
<img src="images/zpusim.PNG" border=0> 
<li>Launch GDB:<p>
../install/bin/zpu-elf-gdb hello.elf
<li>Connect to target, load and run application:<p>
<code>
(gdb) target remote localhost:4444<br>
(gdb) load<br>
(gdb) continue<br>
</code>
<p>
<img src="images/gccgdb.PNG">

</ol>


<a name="introduction"/>
<h1>Architecture introduction</h1>
The ZPU is a zero operand, or stack based CPU. The opcodes have a fixed width of 8 bits. 
<p>
Example:
<p>
<div style="white-space:pre;background-color:#dddddd;">
	<code style="white-space:pre;background-color:#dddddd;">
		IM 5                ; push 5 onto the stack
		LOADSP 20           ; push value at memory location SP+20
		ADD                 ; pop 2 values on the stack and push the result
	</code>
</div>
As can be seen, a lot of information is packed into the 8 bits, e.g. the IM instruction pushes a 7 bit signed integer onto the stack. 
<p>
The choice of opcodes is intimately tied to the GCC toolchain capabilities.
<p>
<div style="white-space:pre;background-color:#dddddd;">
	<code style="white-space:pre;background-color:#dddddd;">
	/* simple program showing some interesting qualities of the ZPU toolchain */
	void bar(int);
	int j;
	void foo(int a, int b, int c)
	{
	  a++;
	  b+=a;
	  j=c;
	  bar(b);
	}

foo:
 loadsp 4	; a is at memory location SP+4
 im 1
 add
 loadsp 12	; b is now at memory location SP+12
 add
 loadsp 16	; c is now at memory location SP+16
 im 24		; «j» is at absolute memory location 24. 
; Notice how the ZPU toolchain is using link-time relaxation
; to squeeze the address into a single no-op
 store
 im 22		; the fn bar is at address 22
 call
 im 12
 return	; 12 bytes of arguments + return from fn
</code>
</div>

<a name="instructionset"/>
<h1>Instruction set</h1>
Only the base instructions are implemented in the architecture. More advanced instructions, like ASHIFTLEFT are emulated in the illegal instruction vector.

All operations are 32 bit wide.
<table border="1">
	<tr><td>Name</td><td>Opcode</td><td>Description</td><td>Definition</td></tr>
	<tr>
		<td>
			BREAKPOINT
		</td>
		<td>
			00000000
		</td>
		<td>
			The debugger sets a memory location to this value to set a breakpoint. Once a JTAG-like 
			debugger interface is added, it will be convenient to be able to distinguish 
			between a breakpoint and an illegal(possibly emulated) instruction.
		</td>
		<td>
			No effect on registers
		</td>
	</tr>
	<tr>
		<td>
			IM
		</td>
		<td>
			1xxx xxxx
		</td>
		<td>
			Pushes 7 bit sign extended integer and sets the a «instruction decode interrupt mask» flag(IDIM).
			<p> 
			If the IDIM flag is already set, this instruction shifts the value on the stack left by 7 bits and stores the 7 bit immediate value into the lower 7 bits.
			<p> 
			Unless an instruction is listed as treating the IDIM flag specially, it should be assumed to clear the IDIM flag.
			<p> 
			To push a 14 bit integer onto the stack, use two consequtive IM instructions. 
			<p> 
			If multiple immediate integers are to be pushed onto the stack, they must be interleaved with another instruction, typically NOP.
		</td>
		<td>
			<code style="white-space:pre;">
pc <= pc + 1 <br>
idim <= 1 <br>
if (idim=0) then <br>
	sp <= sp - 1; <br>
	for i in wordSize-1 downto 7 loop <br>
		mem(sp)(i) <= opcode(6) <br>
	end loop <br>
	mem(sp)(6 downto 0) <= opcode(6 downto 0) <br>
else <br>
	mem(sp)(wordSize-1 downto 7) <= mem(sp)(wordSize-8 downto 0) <br>
	mem(sp)(6 downto 0) <= opcode(6 downto 0) <br>
end if
			</code>

		</td>
	</tr>
	<tr>
		<td>
			STORESP
		</td>
		<td>
			010x xxxx
		</td>
		<td>
			Pop value off stack and store it in the SP+xxxxx*4 memory location, where xxxxx is a positive integer.
		</td>
		<td>
		</td>
	</tr>
	<tr>
		<td>
			LOADSP
		</td>
		<td>
			011x xxxx
		</td>
		<td>
			Push value of memory location SP+xxxxx*4, where xxxxx is a positive integer, onto stack.
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			ADDSP
		</td>
		<td>
			0001 xxxx
		</td>
		<td>
			Add value of memory location SP+xxxx*4 to value on top of stack.
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			EMULATE
		</td>
		<td>
			001x xxxx
		</td>
		<td>
			Push PC to stack and set PC to 0x0+xxxxx*32. This is used to emulate opcodes. See 
			zpupgk.vhd for list of emulate opcode values used. zpu_core.vhd contains 
			reference implementations of these instructions rather than letting the ZPU execute the EMULATE instruction
			<p>
			One way to improve performance of the ZPU is to implement some of
			the EMULATE instructions. 
			
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			PUSHPC
		</td>
		<td>
			emulated
		</td>
		<td>
			Pushes program counter onto the stack.
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			POPPC
		</td>
		<td>
			0000 0100
		</td>
		<td>
			Pops address off stack and sets PC
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			LOAD
		</td>
		<td>
			0000 1000
		</td>
		<td>
			Pops address stored on stack and loads the value of that address onto stack.
			<p>
			Bit 0 and 1 of address are always treated as 0(i.e. ignored) by
			the HDL implementations and C code is guaranteed by the programming
			model never to use 32 bit LOAD on non-32 bit aligned addresses(i.e.
			if a program does this, then it has a bug). 
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			STORE
		</td>
		<td>
			0000 1100
		</td>
		<td>
			Pops address, then value from stack and stores the value into the memory location of the address.
			<p>
			Bit 0 and 1 of address are always treated as 0
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			PUSHSP
		</td>
		<td>
			0000 0010
		</td>
		<td>
			Pushes stack pointer. 
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			POPSP
		</td>
		<td>
			0000 1101
		</td>
		<td>
			Pops value off top of stack and sets SP to that value. Used to allocate/deallocate space on stack for variables or when changing threads. 
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			ADD
		</td>
		<td>
			0000 0101
		</td>
		<td>
			Pops two values on stack adds them and pushes the result
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			AND
		</td>
		<td>
			0000 0110
		</td>
		<td>
			Pops two values off the stack and does a bitwise-and & pushes the result onto the stack
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			OR
		</td>
		<td>
			0000 0111
		</td>
		<td>
			Pops two integers, does a bitwise or and pushes result
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			NOT
		</td>
		<td>
			0000 1001
		</td>
		<td>
			Bitwise inverse of value on stack

		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			FLIP
		</td>
		<td>
			0000 1010
		</td>
		<td>
			Reverses the bit order of the value on the stack, i.e. abc->cba, 100->001, 110->011, etc.
			<p>
			The raison d'etre for this instruction is mainly to emulate other instructions. 
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			NOP
		</td>
		<td>
			0000 1011
		</td>
		<td>
			No operation, clears IDIM flag as side effect, i.e. used between two
			consequtive IM instructions to push two values onto the stack.
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			PUSHSPADD
		</td>
		<td>
			61
		</td>
		<td>
            a=sp; <br>
            b=popIntStack()*4;<br>
            pushIntStack(a+b);<br>
		</td>
		<td>
			
		</td>
	</tr>
	
	<tr>
		<td>
			POPPCREL
		</td>
		<td>
			57
		</td>
		<td>
			setPc(popIntStack()+getPc());
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			SUB
		</td>
		<td>
			49
		</td>
		<td>
			int a=popIntStack();<br>
                            int b=popIntStack();<br>
                            pushIntStack(b-a);<br>
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			XOR
		</td>
		<td>
			50
		</td>
		<td>
pushIntStack(popIntStack() ^ popIntStack());
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			LOADB
		</td>
		<td>
			51
		</td>
		<td>
				8 bit load instruction. Really only here for compatibility with
		C programming model. Also it has a big impact on DMIPS test.
		<p>
			pushIntStack(cpuReadByte(popIntStack())&0xff);
		</td>
		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			STOREB
		</td>
		<td>
			52
		</td>
		<td>
		8 bit store instruction. Really only here for compatibility with
		C programming model. Also it has a big impact on DMIPS test.
		<p>
			addr = popIntStack();<br>
                            val = popIntStack();<br>
                            cpuWriteByte(addr, val);
</td>
		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			LOADH
		</td>
		<td>
			34
		</td>
		<td>
		
				16 bit load instruction. Really only here for compatibility with
		C programming model.
		<p>
		
			pushIntStack(cpuReadWord(popIntStack()));
		</td>
		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			STOREH
		</td>
		<td>
			35
		</td>
		<td>
		16 bit store instruction. Really only here for compatibility with
		C programming model.
		<p>
addr = popIntStack();<br>
                            val = popIntStack();<br>
                            cpuWriteWord(addr, val);
		</td>
		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			LESSTHAN
		</td>
		<td>
			36
		</td>
		<td>
		Signed comparison<br>
                            a = popIntStack();<br>
                            b = popIntStack();<br>
                            pushIntStack((a < b) ? 1 : 0);<br>
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			LESSTHANOREQUAL
		</td>
		<td>
			37
		</td>
		<td>
		Signed comparison<br>
 a = popIntStack();<br>
                            b = popIntStack();<br>
                            pushIntStack((a <= b) ? 1 : 0);
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			ULESSTHAN
		</td>
		<td>
			37
		</td>
		<td>
		Unsigned comparison<br>
                            long a;//long is here 64 bit signed integer<br>
                            long b;<br>
                            a = ((long) popIntStack()) & INTMASK; // INTMASK is unsigned 0x00000000ffffffff<br>
                            b = ((long) popIntStack()) & INTMASK;<br>
                            pushIntStack((a < b) ? 1 : 0);
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			ULESSTHANOREQUAL
		</td>
		<td>
			39
		</td>
		<td>
		Unsigned comparison<br>
                            long a;//long is here 64 bit signed integer<br>
                            long b;<br>
                            a = ((long) popIntStack()) & INTMASK; // INTMASK is unsigned 0x00000000ffffffff<br>
                            b = ((long) popIntStack()) & INTMASK;<br>
                            pushIntStack((a <= b) ? 1 : 0);
		</td>
		<td>
			
		</td>
	</tr>
	<tr>
		<td>
			EQBRANCH
		</td>
		<td>
			55
		</td>
		<td>
                            int compare;<br>
                            int target;<br>
                            target = popIntStack() + pc;<br>
                            compare = popIntStack();<br>
                            if (compare == 0)<br>
                            {<br>
                                setPc(target);<br>
                            } else<br>
                            {<br>
                                setPc(pc + 1);<br>
                            }
		</td>
		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			 NEQBRANCH
		</td>
		<td>
			56
		</td>
		<td>
                            int compare;<br>
                            int target;<br>
                            target = popIntStack() + pc;<br>
                            compare = popIntStack();<br>
                            if (compare != 0)<br>
                            {<br>
                                setPc(target);<br>
                            } else<br>
                            {<br>
                                setPc(pc + 1);<br>
                            }<br>
		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			 MULT
		</td>
		<td>
			41
		</td>
		<td>
			Signed 32 bit multiply <br>
   			pushIntStack(popIntStack() * popIntStack());
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			 DIV
		</td>
		<td>
			53
		</td>
		<td>
		Signed 32 bit integer divide.<br>
                            a = popIntStack();<br>
                            b = popIntStack();<br>
                            if (b == 0)<br>
                            {<br>
                            	// undefined<br> 
                            }
                            pushIntStack(a / b);<br>
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			 MOD
		</td>
		<td>
			54
		</td>
		<td>
		Signed 32 bit integer modulo.<br>
                            a = popIntStack(); <br>
                            b = popIntStack();<br>
                            if (b == 0)<br>
                            {<br>
                            	// undefined <br> 
                            }<br>
                            pushIntStack(a % b); <br>
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			LSHIFTRIGHT	
		</td>
		<td>
			42
		</td>
		<td>
			unsigned shift right.<br>
	        long shift;<br>
	        long valX;<br>
	        int t;<br>
	        shift = ((long) popIntStack()) & INTMASK;<br>
	        valX = ((long) popIntStack()) & INTMASK;<br>
	        t = (int) (valX >> (shift & 0x3f));<br>
	        pushIntStack(t);<br>
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			ASHIFTLEFT	
		</td>
		<td>
			43
		</td>
		<td>
			arithmetic(signed) shift left.<br>
			
			 long shift;<br>
                            long valX;<br>
                            shift = ((long) popIntStack()) & INTMASK;<br>
                            valX = ((long) popIntStack()) & INTMASK;<br>
                            int t = (int) (valX << (shift & 0x3f));<br>
                            pushIntStack(t);<br>
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			ASHIFTRIGHT	
		</td>
		<td>
			43
		</td>
		<td>
		arithmetic(signed) shift left.<br>
                           long shift;<br>
                            int valX;<br>
                            shift = ((long) popIntStack()) & INTMASK;<br>
                            valX = popIntStack();<br>
                            int t = valX >> (shift & 0x3f);<br>
                            pushIntStack(t);<br>
 
   		</td>
		<td>
			
		</td>
	</tr>
    
   	<tr>
		<td>
			CALL
		</td>
		<td>
			45
		</td>
		<td>
			call procedure.<br>
			<br>
				int address = pop();<br>
                            push(pc + 1);<br>
                            setPc(address); <br>
   		</td>
		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			 CALLPCREL
		</td>
		<td>
			63
		</td>
		<td>
			call procedure pc relative<br>
			<br>
int address = pop();<br>
                            push(pc + 1);<br>
                            setPc(address+pc);   		</td>
		<td>
			
		</td>
	</tr>
    
    
  	<tr>
		<td>
			 EQ
		</td>
		<td>
			46
		</td>
		<td>
 pushIntStack((popIntStack() == popIntStack()) ? 1 : 0);		<td>
			
		</td>
	</tr>
  	<tr>
		<td>
			 NEQ
		</td>
		<td>
			48
		</td>
		<td>
 pushIntStack((popIntStack() != popIntStack()) ? 1 : 0);		<td>
			
		</td>
	</tr>
 	<tr>
		<td>
			 NEG
		</td>
		<td>
			47
		</td>
		<td>
 pushIntStack(-popIntStack());<td>
			
		</td>
	</tr>
    
	
</table>
<a name="startup"/>
<h1>Custom startup code (aka crt0.s)</h1>
To minimize the size of an application, one important trick is to
strip down the startup code. The startup code contains emulation
of instructions that may never be used by a particular application.
<p>
The startup code is found in the GCC source code under gcc/libgloss/zpu,
but to make the startup code more available, it has been duplicated
into <a href="../sw/startup">zpu/sw/startup</a> 
<p>
To minimize startup size, see <a href="../roadshow/roadshow/codesize/index.html">codesize</a>
demo. This is pretty standard GCC stuff and simple enough once you've
been over it a couple of times.

<a name="implementing"/>
<h1>Implementing your own ZPU</h1>
One of the neat things about the ZPU is that the instruction set and architecture
is very small and it is easy to implement a ZPU from scratch or modify the
existing ZPU implementations.
<p>
Implementing a ZPU can be done without understanding the toolchain in
detail, i.e. using exclusively HDL skills and only a rudimentary
understanding of standard GCC/GDB usage is sufficient. 
<p>
A few tips:
<ul>
<li>Run zpu_core.vhd or zpu_core_small.vhd and generate an instruction trace
from ModelSim or similar. To check that you own implementation is correctly
implemented, verify that the instruction trace for the new and old
ZPU implementations match. This gives you a simple way to do regression
tests as you develop your ZPU.
<li>To improve performance, you can add more instructions. The EMULATE instructions
are optional in HDL since they will be emulated in software if they are not
implemented in HDL. This allows you to run the ZPU executables unmodified
regardless of which EMULATE instructions you implement.
<li>Run the DMIPS test to measure your overall performance 
<li>Run the histogram.perl script on the instruction trace to generate
histograms of the instructions. Profiling is essential to making
the right choices w.r.t. optimisation for your application. 
</ul>


<a name="vectors"/>
<h1>Vectors</h1>
<table border="1">
	<tr><td>Address</td><td>Name</td><td>Description</td></tr>
	<tr>
		<td>0x000</td>
		<td>Reset</td>
		<td>
			1.When the ZPU boots, this is the first instruction to be executed.
			<p>
			2.The stack pointer is initialised to maximum RAM address
			</td>
	</tr>
	<tr>
		<td>0x020</td>
		<td>Interrupt</td>
		<td>
			This is the entry point for interrupts.
		</td>
	</tr>
	<tr>
		<td>0x040-</td>
		<td>Emulated instructions</td>
		<td>
			Emulated opcode 34. Note that opcode 32 and opcode 33 are not normally used to emulate instructions as these memory addresses are already used by boot vector, GCC registers and the interrupt vector.
		</td>
	</tr>
</table>

<a name="memorymap"/>
<h1>Phi memory map</h1>
The ZPU architecture does not define a memory map as such, but the GCC + libgloss + ecos hal library uses the
memory map below. "Phi" is just a three letter word for the particular memory layout below that came about
while developing the ZPU.
<p>
	<TABLE WIDTH=604 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0 STYLE="page-break-after: avoid">
		<COL WIDTH=85>
		<COL WIDTH=42>
		<COL WIDTH=136>
		<COL WIDTH=283>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2><B>Address</B></FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2><B>Type</B></FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2><B>Name</B></FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2><B>Description</B></FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0000</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">ZPU
				enable</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:1] Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]	Enable ZPU operations</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	ZPU
				is held in Idle mode</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	ZPU
				running</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A000C</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read/</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">ZPU
				UART to ARM7 TX</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt"><B>NOTE!
				ZPU side</B></FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:9] Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[8]	TX buffer ready (valid on ready)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	TX
				buffer not ready (full)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	TX
				buffer ready</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[7:0]	TX byte (valid on write)</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0010</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">ZPU
				UART to ARM7 RX</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt"><B>NOTE!
				ZPU side</B></FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:9] Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[8]	RX buffer data valid</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	TX
				buffer not valid</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	TX
				buffer valid</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[7:0]	RX byte (when valid)</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0014</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read/</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Counter(1)</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]	Reset counter (valid for write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	N/A</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Reset
				counter</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[1]	Sample counter (valid for write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	N/A</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Sample
				counter</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:0]		Counter bit 31:0</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0018</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Counter(2)</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:0]		Counter bit 63:32</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0020</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read
				/ Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Global_Interrupt_mask</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:1]		Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		Global intr. Mask</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	Interrupts
				enabled</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupts
				disabled</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0024</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">UART_INTERRUPT_ENABLE</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:1]		Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		UART RX interrupt enable</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	Interrupt
				disable</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				enable</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0028</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">UART_interrupt</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:1]		Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		UART RX interrupt pending (Read)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	No
				interrupt pending</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				pending</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		Clear UART interrupt (Write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	N/A</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				cleared</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A002C</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Timer_Interrupt_enable</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:1]		Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		Timer interrupt  enable</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	Interrupt
				disable</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				enable</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0030</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read
				/</FONT></FONT></P>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Timer_interrupt</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:2]		Not used</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		Timer interrupt pending (Read)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	No
				interrupt pending</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				pending</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[1]		Reset Timer counter (Write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	N/A</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Timer
				counter reset</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[0]		Clear Timer interrupt (Write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	0	N/A</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">	1	Interrupt
				cleared</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">0x080A0034</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Write</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Timer_Period</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:0]		Interrupt period (write)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">		Number
				of clock cycles</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">		between
				timer interrupts</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt"><B>NOTE!
				</B>The timer will start at Timer_Periode value and count <B>down</B>
				to zero, and generate an interrupt</FONT></FONT></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">.0x080A0038</FONT></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Read</FONT></FONT></P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Timer_Counter</FONT></FONT></P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><FONT FACE="Arial, sans-serif"><FONT SIZE=2 STYLE="font-size: 9pt">Bit
				[31:0]		Timer counter (read)</FONT></FONT></P>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=85>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
			<TD WIDTH=42>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=136>
				<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
				</P>
			</TD>
			<TD WIDTH=283>
				<P LANG="en-US" CLASS="western"><BR>
				</P>
			</TD>
		</TR>
	</TABLE>
<a name="wishbone"/>
<h1>Wishbone</h1>
In <a href="../hdl/wishbone" target="_blank">hdl/wishbone</a> there is an implementation
of a wishbone bridge.
<p>
However this wishbone bridge was used together with the <a href="../hdl/zy2000" target="_blank">hdl/zy2000</a> implementation
of the ZPU, which differs slightly from <a href="../hdl/zpu4/core" target="_blank">hdl/zpu4/core</a>.
<p>
The ZY2000 is a complete implementation of the ZPU including: DRAM, soft-MAC, wishbone bridges, GPIO subsystem,
etc. This also included an eCos HAL w/TCP/IP support.
<a name="interrupts"/>
<h1>Interrupts</h1>
The ZPU supports interrupts.
<p>
To trigger an interrupt, the interrupt signal must be asserted. The ZPU does
not define any interrupt disabling mechanism, this must be implemented by the
interrupt controller and controlled via memory mapped IO.
<p>
Interrupts are masked when the IDIM flag is set, i.e.
with consequtive IM instructions.
<p>
The ZPU has an edge triggered interrupt. As the ZPU notices that the interrupt
is asserted, it will execute the interrupt instruction. The interrupt signal
must stay asserted until the ZPU acknowledges it. 
<p>
When the interrupt instruction is executed, the PC will be pushed onto the
stack and the PC will be set to the interrupt vector address (0x20).
<p>
Note that the GCC compiler requires three registers r0,r1,r2,r3 for some
rather uncommon operations. These 32 registers are mapped to memory locations 0x0,
0x4, 0x8, 0xc.  The default interrupt vector at address 0x20 will load the
value of these memory locations onto the stack, call _zpu_interrupt and
restore them.
<p>
See zpu/hdl/zpu4/test/interrupt/ for C code and zpu/hdl/example/simzpu_interrupt.do
for simulation example.
<a name="zpu_core_small.vhd"/>
<h1>About zpu_core_small.vhd</h1>
The small ZPU implements the minimum instruction set. It is optimized for size and simplicity
serving as a reference in both regards.
<p>
It uses a BRAM (dual port RAM w/read/write to both ports) as data & code storage and
is implemented as a simple state machine. 
<p>
Essentially it has three states:
<ol>
<li>Fetch - starts fetch of next instruction
<li>FetchNext - sets up operands for execute cycle
<li>Decode - decodes instruction
<li>Execute - well.. executes instruction
</ol>
The tricky bit is that there is a tiny bit of interleaving of
states since the BRAM takes a cycle to perform a fetch/store. The above is the
normal states the ZPU cycles through unless memory fetch, jumps, etc. take
place.
<a name="performance"/>
<h1>Speeding up the ZPU</h1>
There are two aspects of speeding up the ZPU: making it perform better
for a particular application and toying around with the ZPU architecture.
<h2>Performance tips</h2>
<ol>
<li>Profile. Create a small sample and run in a simulator that is as close
to the real deployment as possible. zpu4/core/histogram.perl is a script
that will tell you which instructions take the most time.
<li> Using the profile output, decide on which emulated instructions that
it makes sense to implement in HDL for your particular application. Modifying
zpu_core_small.vhd is not particularly hard. Most instructions can be
transliterated into zpu_core_small.vhd from zpu_core.vhd without too much
problem.
<li>The memory subsystem may well turn out to be where you should concentrate
your efforts.
</ol>
<h2>Toying around with the architecture</h2>
Again: profile 90% of the time and spend the remaining 10% tinkering 
with the architecture.
<ul>
<li>There is a DMIPS program you can use to measure the performance of
the ZPU in lieu of profiling a real application. The latter is obviously
a superior solution.
<li>Again: use histogram.perl to figure out which instructions you should add
in HDL.
<li>Tinker a bit with Fmax to find the maximum speed rating for your design.
<li>zpu_core_small.vhd should be ca. 1 DMIPS and zpu_core.vhd should yield
about 5-10 DMIPS before adding instructions runs out of steam.
</ul>
If you need to get ca. 20-50 DMIPS out of the ZPU you will have to
write a heavily pipelined architecture with caches(if you are running
against DRAM). This is *tricky*, but some proof of concept work was
done to show 20 DMIPS w/the ZPU(the actual result was discarded since
it was not complete and contained fatal flaws).
<p>
Achieving above 50-100 DMIPS with the current ZPU architecture is probably
a non-starter and a more conventional RISC design makes more sense here.
<p>
The unique advantages of the ZPU is size in terms of HDL & code size.
<a name="zpu_core.vhd"/>
<h1>About zpu_core.vhd</h1>
The zpu_core.vhd has a single port memory interface. All data, code and IO is
accessed through this memory interface.
<p>
It performs better(despite having less memory bandwidth than zpu_core_small.vhd)
since it implements many more instructions.


<a name="nextgen"/>
<h1>Next generation ZPU</h1>
Based on feedback here is a list of a tenuous "consensus" for the next generation
of the ZPU with some tentative ideas on implementation.
<p>
The plan is to update zpu_core.vhd and zpu_core_small.vhd as examples/reference,
and to open up for innovation in the HDL implementation.

<ol>
<li>Reduce minimum code size footprint
<ol>
<li>Add single entry for unknown instructions. PC and unsupported instruction is
pushed onto stack before jumping to unkonwn instruction vector. This makes it possible
to write denser microcode for missing instructions. For emulated opcodes that are 
not in use, the microcode can more easily be disabled. Determining
that e.g. MULT is not used, can be a bit tricky, but disabling it is easy.
<p>
The address of this entry will be 0x10. The reason 0x00 is not used is that 
GCC needs 0x00-0x0b inclusive to store R0-R2(memory mapped GCC registers). 
The reset vector remains 0x0 so the 0x00-0x0f addresses contains the
first few instructions executed by the ZPU. Some very early work has been
done in <a href="../sw/startup/nextgen_crt0.S"> nextgen_crt0.S</a>.
<li>Single entry for *all* unknown instructions does not limit emulation to the
EMULATE instructions today, but instructions such as OR, LOADSP, STORESP, ADDSP,
etc. can also be emulated. This opens up for further reduction in logic usage.
<li>The single entry for all unknown instructions will make it easier to
write a compact custom crt0.s to fit an instruction subset. 
<li>The interrupt is basically an unknown instruction that is injected into
the execution stream.
<li>Possibly modify the java simulator to support the single entry for unknown
instructions.
</ol>
<li>Add floating point add and mult. FADD & FMULT. Option to generate the instructions
from the compiler.
<li>Add GCC support for seperate code/data bus. This may be as "simple" as
writing a custom linker script for the current GCC compiler.
<li>Add some scheme to support custom instructions. Can this be combined with
single entry point for unknown instructions?
<li>Add support to Zylin Embedded CDT for downloading fully functional ZPU
toolchain. The goal is to allow new users to write and simulate simple ZPU
programs in in less than an hour.
<li>Strip away unused instructions from GCC and add options to GCC for not
emitting more advanced instructions. This will e.g. convert MULT/DIV into
function calls to libgcc and thus make it easier to determine that
microcode is not needed.
</ol>
<h2>Next generation ZPU HDL work</h2>
<ol>
<li>Incorporate feedback on FPGA tricks to reduce memory usage: do not
use asynchronous reset?, use BRAMs in synchronous mode to reduce 
complexity of state machine?, seperate code/data bus? Reduce
instruction set further. Goal: <300 LUT's for 32 bit ZPU
<li>Will someone be willing to contribute a heavily pipelined ZPU?
For this to make sense, the performance must hit 20 DMIPS w/DRAM & cache.
This ZPU could run a TCP/IP stack with relevant performance to compete
with stripped down ARM7 type systems.
</ol>


</body>
<html>